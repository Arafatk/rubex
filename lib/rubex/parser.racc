class Rubex::Parser
token 
  kDEF kEND kRETURN 

  kDTYPE_UINT kDTYPE_LINT kDTYPE_LLINT kDTYPE_CHAR kDTYPE_I8   kDTYPE_I16  
  kDTYPE_I32  kDTYPE_I64  kDTYPE_UI8   kDTYPE_UI16 kDTYPE_UI32 kDTYPE_UI64 
  kDTYPE_INT  kDTYPE_F32  kDTYPE_F32   kDTYPE_F64  kDTYPE_F64  kDTYPE_LF64
  kDTYPE_LF64 kDTYPE_ROBJ 

  tLPAREN tRPAREN tIDENTIFIER tNL tCOMMA tSQUOTE

  tPLUS tMINUS tMULTIPLY tDIVIDE tEXPO tMODULUS tEQUAL
prechigh
  left tEXPO
  left tMULTIPLY tDIVIDE tMODULUS
  left tPLUS tMINUS

  right tEQUAL
preclow

rule

  program:
    stmts { result = Node.new(val[0]) }

  stmts:
    stmts stmt tNL { result = [val[0], val[1]] }
  | stmt tNL { result = [val[0]] }
  
  stmt: 
    kDEF fname f_arglist stmts kEND 
      { 
        result = RubyMethodDef.new(val[1], val[2])
        result.add_statements val[3]
      }
  | kRETURN expr { result = Statement::Return.new val[1] }
  | {}

  fname:
    tIDENTIFIER {}

  f_arglist:
    tLPAREN f_args tRPAREN tNL { result = val[1] }

  f_args:
    f_args tCOMMA f_normal_arg 
      { 
        result = ArgumentList.new
        result.push val[0]
        result.push val[2]
      } 
  | f_normal_arg { }

  f_normal_arg:
    kDTYPE_I32 tIDENTIFIER { result = CBaseType.new val[0], val[1] }

  expr:
    tIDENTIFIER binary_op tIDENTIFIER 
      { 
        result = Expression::Addition.new val[0], val[2]
      }

  binary_op:
    tPLUS | tMINUS | tMULTIPLY | tDIVIDE | tEXPO | tMODULUS { result = val[0] }
end

---- header
require_relative 'lexer.rex.rb'
require_relative 'ast.rb'

include Rubex::AST

---- inner
def parse file_name
  @lexer = Rubex::Lexer.new
  @lexer.parse_file file_name
end

def next_token
  @lexer.next_token
end
