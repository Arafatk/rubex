class Rubex::Parser
token 
  kDEF kEND kRETURN kPRINT

  kDTYPE_UINT  kDTYPE_LINT kDTYPE_LLINT kDTYPE_CHAR kDTYPE_I8   kDTYPE_I16  
  kDTYPE_I32   kDTYPE_I64  kDTYPE_UI8   kDTYPE_UI16 kDTYPE_UI32 kDTYPE_UI64 
  kDTYPE_INT   kDTYPE_F32  kDTYPE_F64   kDTYPE_LF64 kDTYPE_LF64 kDTYPE_ROBJ 
  kDTYPE_ULINT kDTYPE_ULLINT

  tLPAREN tRPAREN tIDENTIFIER tNL tCOMMA tSQUOTE EOF

  tPLUS tMINUS tMULTIPLY tDIVIDE tEXPO tMODULUS tASSIGN

  tINTEGER tFLOAT tSINGLE_CHAR
prechigh
  left tEXPO
  left tMULTIPLY tDIVIDE tMODULUS
  left tPLUS tMINUS

  right tASSIGN
preclow

rule

  program:
    methods { result = Node.new(val[0]) }

  methods:
    methods ruby_method { result = val[1] }
  | {}

  ruby_method:
    kDEF f_name f_arglist stmts kEND eol
      { 
        result = RubyMethodDef.new(val[1], val[2])
        result.add_statements val[3]
      }

  stmts:
    stmts stmt eol { result = [val[0], val[1]] }
  | stmt eol { result = [val[0]] }
  
  stmt:
    var_decl_or_init {  }
  | kRETURN expr { result = Statement::Return.new val[1] }
  | kPRINT expr { result = Statement::Print.new val[1] }
  | {}

  var_decl_or_init:
    dtype decl_or_init 
      { 
        result = Statement::VariableDeclaration.new val[0], *val[1] 
      }
  | normal_init 
      {
        result = Statement::VariableDeclaration.new 'object', *val[0]
      } # ruby inits

  decl_or_init:
    decl_or_init tCOMMA normal_init { result = val[2] }
  | decl_or_init tCOMMA normal_decl { result = val[2] }
  | normal_decl {result = val[0]}
  | normal_init {result = val[0]}

  normal_decl:
    tIDENTIFIER { }

  normal_init:
    tIDENTIFIER tASSIGN literal { result = [val[0], val[2]] }

  literal:
    tINTEGER {}
  | tFLOAT   {}
  | tSINGLE_CHAR { result = val[0][1] }
    
  f_name:
    tIDENTIFIER {}

  f_arglist:
    tLPAREN f_args tRPAREN eol { result = ArgumentList.new val[1] }

  f_args:
    f_args tCOMMA f_normal_arg 
      { 
        result = [*val[0], val[2]]
      } 
  | f_normal_arg { result = val[0] }

  f_normal_arg:
    dtype tIDENTIFIER { result = CBaseType.new val[0], val[1] }

  expr:
    tIDENTIFIER binary_op tIDENTIFIER
      { 
        result = Expression::Addition.new val[0], val[2]
      }
  | tIDENTIFIER {}

  dtype:
    kDTYPE_UINT  | kDTYPE_LINT | kDTYPE_LLINT | kDTYPE_CHAR | kDTYPE_I8   | 
    kDTYPE_I16   | kDTYPE_I32  | kDTYPE_I64   | kDTYPE_UI8  | kDTYPE_UI16 | 
    kDTYPE_UI32  | kDTYPE_UI64 | kDTYPE_INT   | kDTYPE_F32  | kDTYPE_F64  | 
    kDTYPE_LF64  | kDTYPE_ROBJ | kDTYPE_ULINT | kDTYPE_ULLINT 
      {
        result = val[0]
      }

  binary_op:
    tPLUS | tMINUS | tMULTIPLY | tDIVIDE | tEXPO | tMODULUS { result = val[0] }

  eol:
    tNL {}
end

---- header
require_relative 'lexer.rex.rb'
require_relative 'ast.rb'

include Rubex::AST

---- inner
def parse file_name
  @lexer = Rubex::Lexer.new
  @lexer.parse_file file_name
end

def next_token
  @lexer.next_token
end
